<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Analysis Control Center - News MCP</title>
    <script src="//unpkg.com/htmx.org@1.9.8"></script>
    <script src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js" defer></script>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.0/font/bootstrap-icons.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    <link rel="stylesheet" href="/static/news-mcp.css">
    <link rel="stylesheet" href="/static/css/analysis.css?v=20250924-2">
    <style>
        body {
            background-color: #0d1117 !important;
            color: #c9d1d9 !important;
        }
        .container-fluid {
            background-color: #0d1117 !important;
        }
        h2, h5 {
            color: #c9d1d9 !important;
        }
    </style>
</head>
<body class="bg-dark">
    <!-- Header -->
    <nav class="navbar navbar-expand-lg navbar-dark bg-dark">
        <div class="container">
            <a class="navbar-brand" href="/">
                <i class="fas fa-rss"></i> News MCP
            </a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <div class="navbar-nav ms-auto">
                    <a class="nav-link" href="/admin/feeds">
                        <i class="fas fa-rss"></i> Feeds
                    </a>
                    <a class="nav-link" href="/admin/items">
                        <i class="fas fa-newspaper"></i> Articles
                    </a>
                    <a class="nav-link active" href="/admin/analysis">
                        <i class="fas fa-brain"></i> Analysis
                    </a>
                    <a class="nav-link" href="/admin/templates">
                        <i class="fas fa-cogs"></i> Templates
                    </a>
                    <a class="nav-link" href="/admin/statistics">
                        <i class="fas fa-chart-line"></i> Statistics
                    </a>
                    <a class="nav-link" href="/admin/database">
                        <i class="fas fa-database"></i> Database
                    </a>
                    <a class="nav-link" href="/admin/health">
                        <i class="fas fa-heartbeat"></i> Health
                    </a>
                </div>
            </div>
        </div>
    </nav>

    <div class="container-fluid mt-4">
        <div class="row">
            <div class="col-12">
                <h2 class="mb-lg">üß† Analysis Control Center</h2>
            </div>
        </div>

        <!-- 3-Tab Navigation -->
        <div class="nmc-tabs mb-lg">
            <button class="nmc-tab active" onclick="switchTab('start-analysis')">
                ‚ñ∂Ô∏è Start Analysis
            </button>
            <button class="nmc-tab" onclick="switchTab('active-runs')">
                üîÑ Active Runs
            </button>
            <button class="nmc-tab" onclick="switchTab('settings')">
                ‚öôÔ∏è Settings
            </button>
        </div>

        <!-- Tab Content -->
        <div x-data="analysisControl()">
            <!-- Start Analysis Tab -->
            <div id="start-analysis-tab" class="tab-content">
                <form id="analysis-form">
                    <!-- Horizontal System Statistics -->
                    <div id="stats-horizontal"
                         hx-get="/htmx/analysis/stats-horizontal"
                         hx-trigger="load, every 30s"
                         hx-swap="innerHTML">
                        <div class="d-flex justify-content-center py-3">
                            <div class="spinner-border text-primary" role="status">
                                <span class="visually-hidden">Loading statistics...</span>
                            </div>
                        </div>
                    </div>

                    <div class="row" x-data="analysisControl">
                        <!-- Left Column: Target Selection + Controls -->
                        <div class="col-lg-5">
                            <!-- Target Selection -->
                            <div class="nmc-card">
                                <h5 class="mb-md">üéØ Target Selection</h5>
                                <div>
                                    {% include 'partials/analysis_target_selection.html' %}
                                </div>
                            </div>

                            <!-- Model & Parameters -->
                            <div class="nmc-card">
                                <h5 class="mb-md">‚öôÔ∏è Model & Parameters</h5>
                                <div>
                                    {% include 'partials/analysis_model_params.html' %}
                                </div>
                            </div>

                            <!-- Additional Settings -->
                            <div class="nmc-card">
                                <h5 class="mb-md">‚öôÔ∏è Additional Settings</h5>
                                <div>
                                    {% include 'partials/analysis_additional_settings.html' %}
                                </div>
                            </div>

                            <!-- Preview & Start -->
                            <div class="nmc-card">
                                <h5 class="mb-md">üìä Preview & Start</h5>
                                <div id="alpine-preview-container">
                                    {% include 'partials/analysis_preview_start.html' %}
                                </div>
                            </div>
                        </div>

                        <!-- Right Column: Live Articles -->
                        <div class="col-lg-7">
                            <div id="articles-live"
                                 hx-get="/htmx/analysis/articles-live"
                                 hx-trigger="load"
                                 hx-swap="innerHTML">
                                <div class="card bg-dark border-secondary">
                                    <div class="card-body d-flex justify-content-center align-items-center" style="min-height: 400px;">
                                        <div class="text-center">
                                            <div class="spinner-border text-primary mb-3" role="status">
                                                <span class="visually-hidden">Loading articles...</span>
                                            </div>
                                            <p class="text-muted">Loading live articles...</p>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </form>
            </div>

            <!-- Active Runs Tab -->
            <div id="active-runs-tab" class="tab-content" style="display:none;">
                <div class="row">
                    <div class="col-12">
                        <div id="active-runs-container">
                            {% include 'partials/analysis_active_runs.html' %}
                        </div>

                        <h5 class="mt-lg mb-md">üìú History</h5>
                        <div id="history-container">
                            {% include 'partials/analysis_history.html' %}
                        </div>
                    </div>
                </div>
            </div>

            <!-- Settings Tab -->
            <div id="settings-tab" class="tab-content" style="display:none;">
                <div class="row">
                    <div class="col-lg-8">
                        {% include 'partials/analysis_settings.html' %}
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Load JavaScript -->
    <script src="/static/js/job-manager.js"></script>
    <script src="/static/js/analysis-controller.js"></script>
    <script>
        // Simple tab switching
        function switchTab(tabName) {
            // Hide all tabs
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.style.display = 'none';
            });

            // Remove active class from all tab buttons
            document.querySelectorAll('.nmc-tab').forEach(btn => {
                btn.classList.remove('active');
            });

            // Show selected tab
            document.getElementById(tabName + '-tab').style.display = 'block';

            // Add active class to clicked button
            event.target.classList.add('active');
        }

        // Live Articles Update Functions
        function updateLiveArticles(mode, count = null, feedId = null, dateFrom = null, dateTo = null) {
            const articlesContainer = document.getElementById('articles-live');
            if (!articlesContainer) return;

            // Build URL with parameters
            let url = '/htmx/analysis/articles-live?mode=' + mode;

            if (count && (mode === 'latest' || mode === 'unanalyzed')) {
                url += '&count=' + count;
            }
            if (feedId && mode === 'feed') {
                url += '&feed_id=' + feedId;
            }
            if (dateFrom && dateTo && mode === 'date_range') {
                url += '&date_from=' + encodeURIComponent(dateFrom);
                url += '&date_to=' + encodeURIComponent(dateTo);
            }

            // Show loading indicator
            articlesContainer.innerHTML = `
                <div class="card bg-dark border-secondary">
                    <div class="card-body d-flex justify-content-center align-items-center" style="min-height: 400px;">
                        <div class="text-center">
                            <div class="spinner-border text-primary mb-3" role="status">
                                <span class="visually-hidden">Updating articles...</span>
                            </div>
                            <p class="text-muted">Updating live articles...</p>
                        </div>
                    </div>
                </div>
            `;

            // Fetch and update
            fetch(url)
                .then(response => response.text())
                .then(html => {
                    articlesContainer.innerHTML = html;
                })
                .catch(error => {
                    console.error('Error updating live articles:', error);
                    articlesContainer.innerHTML = `
                        <div class="card bg-dark border-danger">
                            <div class="card-body text-center">
                                <div class="text-danger">
                                    <i class="bi bi-exclamation-triangle mb-2"></i>
                                    <p>Error loading articles. Please try again.</p>
                                </div>
                            </div>
                        </div>
                    `;
                });
        }

        function clearSelection() {
            // Clear the active selection preview
            document.getElementById('active-selection').innerHTML = '';

            // Reset articles to show all (default)
            updateLiveArticles('all');
        }

        // Auto-refresh articles every 2 minutes
        setInterval(() => {
            const articlesContainer = document.getElementById('articles-live');
            if (articlesContainer && articlesContainer.innerHTML.includes('Live Articles')) {
                // Only refresh if no active selection is shown
                const activeSelection = document.getElementById('active-selection');
                if (!activeSelection || activeSelection.innerHTML.trim() === '') {
                    updateLiveArticles('all');
                }
            }
        }, 120000); // 2 minutes
    </script>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>

    <!-- Global helper for article updates -->
    <script>
        // Global function to update articles display (fallback if Alpine.js fails)
        window.updateArticlesGlobal = function(mode, count, feedId) {
            console.log('[Global] Updating articles:', mode, count, feedId);
            const container = document.getElementById('articles-live');
            if (!container) {
                console.error('[Global] articles-live container not found');
                return;
            }

            let url = '/htmx/analysis/articles-live?';

            if (mode === 'latest') {
                url += `mode=latest&count=${count || 50}`;
            } else if (mode === 'timeRange') {
                // For timeRange, count represents total hours
                url += `mode=time_range&hours=${count || 24}`;
            } else if (mode === 'unanalyzed') {
                url += `mode=unanalyzed&count=${count || 100}`;
            }

            if (feedId) {
                url += `&feed_id=${feedId}`;
            }

            console.log('[Global] Fetching from:', url);

            // Show loading
            container.innerHTML = `
                <div class="card bg-dark border-secondary">
                    <div class="card-body text-center p-5">
                        <div class="spinner-border text-primary" role="status">
                            <span class="visually-hidden">Loading...</span>
                        </div>
                        <p class="mt-3 text-muted">Loading articles...</p>
                    </div>
                </div>
            `;

            fetch(url)
                .then(response => {
                    if (!response.ok) throw new Error('Failed to load');
                    return response.text();
                })
                .then(html => {
                    container.innerHTML = html;
                    console.log('[Global] Articles updated');
                })
                .catch(error => {
                    console.error('[Global] Error:', error);
                    container.innerHTML = `
                        <div class="card bg-dark border-danger">
                            <div class="card-body text-center">
                                <p class="text-danger">Error loading articles</p>
                            </div>
                        </div>
                    `;
                });
        };
    </script>

    <script>
    document.addEventListener('alpine:init', () => {
        Alpine.data('analysisControl', () => ({
            // ========== CENTRAL RUN DATA STRUCTURE ==========
            futureRun: {
                // What articles to analyze
                selection: {
                    mode: 'latest',      // latest, timeRange, unanalyzed
                    count: 50,           // Number of articles (for latest/unanalyzed)
                    days: 7,             // For timeRange mode
                    hours: 0,            // For timeRange mode
                    feed_id: null,       // Optional: specific feed filter
                },

                // Model configuration
                model: {
                    tag: 'gpt-4.1-nano',
                    rate_per_second: 1.0,
                    limit: 200           // Max articles per run
                },

                // Additional settings
                settings: {
                    override_existing: false  // Re-analyze already processed articles
                },

                // Computed values (auto-calculated)
                computed: {
                    articles_to_analyze: 50,
                    estimated_cost: 0.005,
                    estimated_minutes: 1,
                    limit_exceeded: false,
                    description: 'Latest 50 articles'
                }
            },

            // ========== UI INPUT STATE (temporary values while typing) ==========
            uiInput: {
                latestCount: 50,
                timeRangeDays: 7,
                timeRangeHours: 0,
                useFeedFilter: false,
                selectedFeedId: ''
            },

            // ========== UI STATE ==========
            availableFeeds: [],  // Will be loaded from database
            currentJobStatus: {
                status: 'idle',
                message: '',
                id: null
            },
            loading: false,

            // ========== MODEL COSTS REFERENCE ==========
            modelCosts: {
                'gpt-5': { input: 1.25, output: 10.00 },
                'gpt-5-mini': { input: 0.25, output: 2.00 },
                'gpt-5-nano': { input: 0.05, output: 0.40 },
                'gpt-5-chat-latest': { input: 1.25, output: 10.00 },
                'gpt-5-codex': { input: 1.25, output: 10.00 },
                'gpt-4.1': { input: 2.00, output: 8.00 },
                'gpt-4.1-mini': { input: 0.40, output: 1.60 },
                'gpt-4.1-nano': { input: 0.10, output: 0.40 },
                'gpt-4o': { input: 2.50, output: 10.00 },
                'gpt-4o-2024-05-13': { input: 5.00, output: 15.00 },
                'gpt-4o-mini': { input: 0.15, output: 0.60 }
            },

            // ========== BACKWARD COMPATIBILITY ALIASES ==========
            // These map UI inputs to the uiInput object
            get selectionMode() { return this.futureRun.selection.mode; },
            set selectionMode(val) { this.futureRun.selection.mode = val; },

            get latestCount() { return this.uiInput.latestCount; },
            set latestCount(val) { this.uiInput.latestCount = parseInt(val) || 50; },

            get timeRangeDays() { return this.uiInput.timeRangeDays; },
            set timeRangeDays(val) { this.uiInput.timeRangeDays = parseInt(val) || 0; },

            get timeRangeHours() { return this.uiInput.timeRangeHours; },
            set timeRangeHours(val) { this.uiInput.timeRangeHours = parseInt(val) || 0; },

            // Direct access to futureRun sections for x-model bindings
            // Keep for backward compatibility with old filter references
            get filters() {
                return {
                    useFeedFilter: this.uiInput.useFeedFilter,
                    feed_id: this.uiInput.selectedFeedId,
                    override_existing: this.futureRun.settings.override_existing
                };
            },

            get params() { return this.futureRun.model; },

            // Preview always shows computed values from futureRun
            get preview() {
                return {
                    total_items: this.futureRun.selection.count || 0,
                    item_count: this.futureRun.selection.count || 0,
                    already_analyzed: 0,
                    already_analyzed_count: 0,
                    new_items_count: this.futureRun.computed.articles_to_analyze,
                    estimated_cost_usd: this.futureRun.computed.estimated_cost,
                    estimated_duration_minutes: this.futureRun.computed.estimated_minutes,
                    limit_exceeded: this.futureRun.computed.limit_exceeded
                };
            },

            get activeSelection() {
                return {
                    mode: this.futureRun.selection.mode,
                    count: this.futureRun.selection.count,
                    description: this.futureRun.computed.description
                };
            },

            // ========== INITIALIZATION ==========
            init() {
                console.log('Initializing Analysis Control with futureRun');

                // Load available feeds from database
                this.loadAvailableFeeds();

                // Load saved futureRun if exists
                const savedRun = localStorage.getItem('futureRun');
                if (savedRun) {
                    try {
                        const saved = JSON.parse(savedRun);
                        this.futureRun = { ...this.futureRun, ...saved };
                        // Sync UI inputs
                        this.uiInput.latestCount = this.futureRun.selection.count;
                        this.uiInput.timeRangeDays = this.futureRun.selection.days;
                        this.uiInput.timeRangeHours = this.futureRun.selection.hours;
                        if (this.futureRun.selection.feed_id) {
                            this.uiInput.useFeedFilter = true;
                            this.uiInput.selectedFeedId = this.futureRun.selection.feed_id;
                        }
                    } catch (e) {
                        console.error('Failed to load saved run:', e);
                    }
                }

                // Load saved default model params
                const savedParams = localStorage.getItem('defaultModelParams');
                if (savedParams) {
                    try {
                        const params = JSON.parse(savedParams);
                        this.futureRun.model = { ...this.futureRun.model, ...params };
                    } catch (e) {
                        console.error('Failed to load saved params:', e);
                    }
                }

                // Initial computation
                this.computeValues();
                this.updateArticlesDisplay();
            },

            // ========== LOAD FEEDS FROM DATABASE ==========
            async loadAvailableFeeds() {
                console.log('Loading available feeds from database');

                // First clear any old cached data
                this.availableFeeds = [];

                try {
                    // Use the simple feeds endpoint via proxy
                    const response = await fetch('/api/feeds-simple/list', {
                        cache: 'no-cache',  // Force fresh data
                        headers: {
                            'Cache-Control': 'no-cache'
                        }
                    });

                    console.log('API Response status:', response.status);

                    if (response.ok) {
                        const feeds = await response.json();
                        console.log('Raw feeds from API:', feeds);

                        // Already filtered by the API, just use them
                        this.availableFeeds = feeds;
                        console.log('Available feeds:', this.availableFeeds);
                        console.log(`Loaded ${this.availableFeeds.length} active feeds`);

                        // Debug: Log first 5 feeds
                        if (this.availableFeeds.length > 0) {
                            console.log('First 5 feeds:', this.availableFeeds.slice(0, 5).map(f => ({id: f.id, title: f.title})));
                        }

                        // If a feed was previously selected but no longer exists, clear it
                        if (this.futureRun.selection.feed_id) {
                            const feedExists = this.availableFeeds.find(f => f.id == this.futureRun.selection.feed_id);
                            if (!feedExists) {
                                console.log('Previously selected feed no longer exists, clearing selection');
                                this.futureRun.selection.feed_id = null;
                                this.uiInput.selectedFeedId = '';
                                this.uiInput.useFeedFilter = false;
                            }
                        }
                    } else {
                        console.error('Failed to load feeds:', response.status, response.statusText);
                        this.availableFeeds = [];
                    }
                } catch (error) {
                    console.error('Error loading feeds:', error);
                    this.availableFeeds = [];
                }
            },

            // ========== COMPUTE FUNCTION ==========
            computeValues() {
                const run = this.futureRun;
                const count = run.selection.count || 0;
                const limit = run.model.limit;

                // Calculate articles to analyze
                run.computed.articles_to_analyze = Math.min(count, limit);
                run.computed.limit_exceeded = count > limit;

                // Calculate cost
                const costs = this.modelCosts[run.model.tag] || this.modelCosts['gpt-4.1-nano'];
                const tokensPerArticle = { input: 500, output: 100 };
                const costPerArticle = (tokensPerArticle.input * costs.input + tokensPerArticle.output * costs.output) / 1000000;
                run.computed.estimated_cost = run.computed.articles_to_analyze * costPerArticle;

                // Calculate time
                run.computed.estimated_minutes = Math.ceil(run.computed.articles_to_analyze / (run.model.rate_per_second * 60));

                // Update description (including feed if selected)
                let desc = '';
                if (run.selection.mode === 'latest') {
                    desc = `Latest ${count} articles`;
                } else if (run.selection.mode === 'timeRange') {
                    desc = `Articles from last ${run.selection.days}d ${run.selection.hours}h`;
                } else if (run.selection.mode === 'unanalyzed') {
                    desc = 'All unanalyzed articles';
                }

                // Add feed name if specific feed is selected
                if (run.selection.feed_id) {
                    const feed = this.availableFeeds.find(f => f.id == run.selection.feed_id);
                    if (feed) {
                        desc += ` from ${feed.title}`;
                    }
                }

                run.computed.description = desc;

                // Save to localStorage
                localStorage.setItem('futureRun', JSON.stringify(run));

                console.log('Computed values updated:', run.computed);
            },

            // ========== TARGET SELECTION FUNCTIONS ==========
            setLatestSelection() {
                console.log('setLatestSelection:', this.uiInput.latestCount);

                // Update futureRun with UI input values
                this.futureRun.selection.mode = 'latest';
                this.futureRun.selection.count = this.uiInput.latestCount;

                // Recompute and update displays
                this.computeValues();
                this.updateArticlesDisplay();

                // Fallback: Also call global function
                window.updateArticlesGlobal('latest', this.uiInput.latestCount, this.futureRun.selection.feed_id);
            },

            setTimeRangeSelection() {
                console.log('setTimeRangeSelection:', this.uiInput.timeRangeDays, this.uiInput.timeRangeHours);

                const days = this.uiInput.timeRangeDays;
                const hours = this.uiInput.timeRangeHours;
                const totalHours = days * 24 + hours;

                if (totalHours === 0) {
                    alert('Please specify at least some time range');
                    return;
                }

                // Update futureRun
                this.futureRun.selection.mode = 'timeRange';
                this.futureRun.selection.days = days;
                this.futureRun.selection.hours = hours;
                // For time range, we'll need to fetch the actual count from server
                this.futureRun.selection.count = 100; // Placeholder

                // Recompute and update displays
                this.computeValues();
                this.updateArticlesDisplay();
                this.fetchTimeRangeCount(); // Async update of actual count

                // Fallback: Also call global function
                window.updateArticlesGlobal('timeRange', totalHours, this.futureRun.selection.feed_id);
            },

            setUnanalyzedSelection() {
                console.log('setUnanalyzedSelection');

                // Update futureRun
                this.futureRun.selection.mode = 'unanalyzed';
                this.futureRun.selection.count = 1000; // Placeholder, will fetch actual

                // Recompute and update displays
                this.computeValues();
                this.updateArticlesDisplay();
                this.fetchUnanalyzedCount(); // Async update of actual count

                // Fallback: Also call global function
                window.updateArticlesGlobal('unanalyzed', this.futureRun.model.limit, this.futureRun.selection.feed_id);
            },

            // ========== MODEL PARAMS FUNCTIONS ==========
            applyModelParams() {
                console.log('applyModelParams - only updating model values in futureRun');
                // Model params are already bound to futureRun.model via x-model
                // Just recompute - this won't change selection values!
                this.computeValues();
            },

            saveDefaultParams() {
                console.log('Saving default params:', this.futureRun.model);
                localStorage.setItem('defaultModelParams', JSON.stringify(this.futureRun.model));
                // Simple notification
                const btn = event.target;
                const origText = btn.textContent;
                btn.textContent = '‚úÖ Saved!';
                btn.disabled = true;
                setTimeout(() => {
                    btn.textContent = origText;
                    btn.disabled = false;
                }, 2000);
            },

            // ========== FEED FILTER FUNCTIONS ==========
            applyFeedFilter() {
                console.log('applyFeedFilter - updating futureRun selection feed');

                // Update futureRun selection with feed filter
                if (this.uiInput.useFeedFilter && this.uiInput.selectedFeedId) {
                    this.futureRun.selection.feed_id = parseInt(this.uiInput.selectedFeedId);
                } else {
                    this.futureRun.selection.feed_id = null;
                }

                // Recompute and update displays
                this.computeValues();
                this.updateArticlesDisplay();
            },

            clearFeedFilter() {
                console.log('clearFeedFilter');
                this.uiInput.useFeedFilter = false;
                this.uiInput.selectedFeedId = '';
                this.futureRun.selection.feed_id = null;
                this.computeValues();
                this.updateArticlesDisplay();
            },

            // ========== ASYNC FETCH FUNCTIONS ==========
            async fetchTimeRangeCount() {
                // TODO: Fetch actual article count for time range from server
                // For now, using placeholder
            },

            async fetchUnanalyzedCount() {
                // TODO: Fetch actual unanalyzed count from server
                // For now, using placeholder
            },

            // ========== ARTICLES DISPLAY UPDATE ==========
            async updateArticlesDisplay() {
                console.log('updateArticlesDisplay from futureRun:', this.futureRun);
                const container = document.getElementById('articles-live');
                if (!container) {
                    console.warn('articles-live container not found!');
                    return;
                }

                const run = this.futureRun;
                let url = '/htmx/analysis/articles-live?';

                if (run.selection.mode === 'latest') {
                    url += `mode=latest&count=${run.selection.count}`;
                } else if (run.selection.mode === 'timeRange') {
                    const totalHours = (run.selection.days || 0) * 24 + (run.selection.hours || 0);
                    url += `mode=time_range&hours=${totalHours}&count=1000`;
                } else if (run.selection.mode === 'unanalyzed') {
                    url += `mode=unanalyzed&count=${run.model.limit || 100}`;
                }

                // Add feed filter if specified in selection
                if (run.selection.feed_id) {
                    url += `&feed_id=${run.selection.feed_id}`;
                }

                // Add unanalyzed_only flag for unanalyzed mode
                if (run.selection.mode === 'unanalyzed' || (run.filters && run.filters.unanalyzed_only)) {
                    url += `&unanalyzed_only=true`;
                }

                console.log('Fetching articles from:', url);

                // Show loading indicator
                container.innerHTML = `
                    <div class="card bg-dark border-secondary">
                        <div class="card-body d-flex justify-content-center align-items-center" style="min-height: 400px;">
                            <div class="text-center">
                                <div class="spinner-border text-primary mb-3" role="status">
                                    <span class="visually-hidden">Loading articles...</span>
                                </div>
                                <p class="text-muted">Loading articles...</p>
                            </div>
                        </div>
                    </div>
                `;

                try {
                    const response = await fetch(url);
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    const html = await response.text();
                    container.innerHTML = html;
                    console.log('Articles updated successfully');
                } catch (error) {
                    console.error('Error updating articles:', error);
                    container.innerHTML = `
                        <div class="card bg-dark border-danger">
                            <div class="card-body text-center">
                                <div class="text-danger">
                                    <i class="bi bi-exclamation-triangle mb-2"></i>
                                    <p>Error loading articles: ${error.message}</p>
                                </div>
                            </div>
                        </div>
                    `;
                }
            },

            // ========== START RUN FUNCTION ==========
            async startRun() {
                console.log('startRun with futureRun:', this.futureRun);

                const run = this.futureRun;
                if (!run.selection.mode) {
                    alert('Please select articles first');
                    return;
                }

                this.loading = true;
                this.currentJobStatus = {
                    status: 'queued',
                    message: 'Starting analysis job...',
                    id: null
                };

                try {
                    // Step 1: Create preview job
                    const selection = {
                        mode: run.selection.mode,
                        count: run.selection.mode === 'latest' ? run.selection.count : undefined,
                        hours: run.selection.mode === 'timeRange' ? (run.selection.days * 24 + run.selection.hours) : undefined,
                        feed_id: run.selection.feed_id || undefined
                    };

                    const parameters = {
                        model_tag: run.model.tag || 'gpt-4.1-nano',
                        rate_per_second: run.model.rate_per_second || 1.0,
                        limit: run.model.limit || run.computed.articles_to_analyze
                    };

                    const filters = {
                        unanalyzed_only: run.selection.mode === 'unanalyzed' || false
                    };

                    const response = await fetch('/api/analysis/jobs/preview', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ selection, parameters, filters })
                    });

                    if (!response.ok) {
                        throw new Error(`Failed to create preview: ${response.statusText}`);
                    }

                    const previewResult = await response.json();
                    const jobId = previewResult.job_id;

                    // Step 2: Confirm job
                    const confirmResponse = await fetch(`/api/analysis/jobs/${jobId}/confirm`, {
                        method: 'POST'
                    });

                    if (!confirmResponse.ok) {
                        throw new Error(`Failed to confirm job: ${confirmResponse.statusText}`);
                    }

                    // Step 3: Start analysis
                    const startResponse = await fetch('/api/analysis/start', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ job_id: jobId })
                    });

                    if (!startResponse.ok) {
                        throw new Error(`Failed to start analysis: ${startResponse.statusText}`);
                    }

                    const startResult = await startResponse.json();

                    this.currentJobStatus = {
                        status: 'running',
                        message: `Analyzing ${run.computed.articles_to_analyze} articles...`,
                        id: startResult.id || startResult.run_id
                    };

                    // Poll for run completion
                    const runId = startResult.id || startResult.run_id;
                    const pollInterval = setInterval(async () => {
                        try {
                            const statusResponse = await fetch(`/api/analysis/runs/${runId}`);
                            if (statusResponse.ok) {
                                const runData = await statusResponse.json();
                                if (runData.status === 'completed') {
                                    this.currentJobStatus = {
                                        status: 'done',
                                        message: `Analysis completed! Processed ${runData.processed_count || 0} items.`,
                                        id: runId
                                    };
                                    clearInterval(pollInterval);
                                    // Reset to idle after 5 seconds
                                    setTimeout(() => {
                                        this.currentJobStatus = { status: 'idle', message: '', id: null };
                                    }, 5000);
                                } else if (runData.status === 'failed' || runData.status === 'cancelled') {
                                    this.currentJobStatus = {
                                        status: 'error',
                                        message: `Analysis ${runData.status}: ${runData.last_error || 'Unknown error'}`,
                                        id: runId
                                    };
                                    clearInterval(pollInterval);
                                    setTimeout(() => {
                                        this.currentJobStatus = { status: 'idle', message: '', id: null };
                                    }, 10000);
                                }
                            }
                        } catch (error) {
                            console.error('Error polling run status:', error);
                        }
                    }, 3000);

                    // Switch to Active Runs tab after 1.5s
                    setTimeout(() => {
                        const activeRunsTab = document.querySelector('[onclick*="switchTab(\'active-runs\')"]');
                        if (activeRunsTab) {
                            activeRunsTab.click();
                        }
                    }, 1500);

                } catch (error) {
                    console.error('Error starting analysis:', error);
                    this.currentJobStatus = {
                        status: 'error',
                        message: error.message || 'Failed to start analysis',
                        id: null
                    };
                    alert('Failed to start analysis: ' + error.message);
                } finally {
                    this.loading = false;
                }
            }
        }))
    });
    </script>
</body>
</html>